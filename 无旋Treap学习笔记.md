## 无旋Treap学习笔记

### 一、前置知识

既然来学 无旋Treap 了那肯定要知道二叉搜索树（Binary Search Tree，简称BST）。

二叉搜索树有这些性质：

1、是一棵二叉树

2、每个节点有一个键值，满足非空左子树的键值都小于当前键值，非空右子树的键值都大于当前键值。

3、每棵子树都是二叉搜索树

我们可以对一棵二叉搜索树进行递归操作。

故而，利用二叉搜索树，我们可以在 $O(h)$ 的复杂度内做到插入、删除、查询排名、询问第 $k$ 大等集合信息维护，这里不再细述。然而，假如将插入数值顺序，那么二叉搜索树就会退化成一条链，极大降低程序效率，所以维护BST的平衡就十分重要。

有若干种平衡树，Treap 是其中一种。

### 二、Treap

Treap 有两种，分为无旋和带旋 Treap。这里介绍 无旋Treap，代码量短，而且有着各种优势（下文会提到）。

但无论是无旋还是非旋，它们都有着共同的思想：随机化。

上文提到，假如插入数值顺序，BST将会退化成链。但假如把插入顺序随机打乱，这样的树就极大可能不会退化成链，达到**期望平衡**。

“把插入顺序随机打乱”，这其实不太可能，但我们有另一种方法可以模拟这种随机插入。

在BST的基础上，我们定义一下每个节点维护的信息：键值 $key$ 和优先级 $priority$。

对于我们要维护的值 $key$ ，满足二叉搜索树的性质；

对于优先级 $priority$ ，满足堆的性质。

$priority$ 在新建节点时随机生成，这样可以达到“模拟插入随机”的目的。 

### 三、无旋Treap

说了那么多，我们终于要迎来本文的主角了——无旋Treap。

要说明的是，无旋Treap 并不是严格的BST，即左右子节点的 $key$ 可能等于当前节点。因此 无旋Treap 维护的多重集不以数值维护节点，每个数相互独立，即便它们数值相同。

我们先来创建一个结构体维护一个节点的信息。本文的 无旋Treap 用指针实现，较为简洁直观。

```cpp
struct node{
	int val,sz,p;
	node *l,*r;
	node(int key,node *son){l=r=son;val=key,sz=1,p=rand();}//两种初始化方式
	node(){l=r=this,val=sz=p=0;}
	bool empty(){return sz==0;}
}*emp=new node(),*root=emp;//根节点和定义的空节点

node *u=new node(key,emp);//建立一个非空节点
```

$val$ 维护当前节点的值，$sz$ 表示以当前节点为根的子树大小，$p$ 是随机产生的优先级。有两个指针 $l$ 和 $r$，分别指向左右节点。空指针容易 RE，所以我们人为定义一个“常量”空节点，让空指针都指向这个节点，可以避免运行错误。

```cpp
inline void update(node *u){
	u->sz=u->l->sz+u->r->sz+1;
}
```

通过 update 来更新节点 $sz$ 信息。

无旋Treap 有两个核心操作：**Split（分裂）** 和 **Merge（合并）**。接下来分别介绍这两个操作。

#### Split

我们通过 Split 操作将整棵树以 $key$ 为标准分裂为两个子树，满足第一棵树所有节点都小于等于 $key$ ，第二棵子树都大于 $key$ 。

```cpp
void split(node *u,int key,node *&x,node *&y){//以u为根节点进行分裂
    //其中，x和y作为参数，分别返回已分裂的两个子树的根节点
	if(u->empty()){//为空则返回
		x=y=emp;return;
	}
	if(u->val<=key) x=u,split(u->r,key,u->r,y);
    //如果u的键值不超过key，那么u与其的左子树全部属于第一棵子树，u直接为根，向右递归寻找剩余节点
	else y=u,split(u->l,key,x,u->l);
    //反之，u与其右子树全部属于第二棵子树，u为第二个根，向左递归寻找剩余节点
	update(u);//记得更新节点
}
```

#### Merge

我们通过 Merge 操作将以 $u$，$v$ 为根的两棵子树合并，但必须满足第一棵子树的键值全部小于第二棵。

合并的时候以 $priority$ 为参照，满足二叉堆的性质。这里使用大根堆，但其实小根堆也是一样的。

```cpp
node *merge(node *u,node *v){//合并u v，返回合并后根节点的指针
	if(u->empty()||v->empty()) return u->empty()?v:u;
    //若有一个是空节点则返回另一个
	if(u->p>v->p){//u的优先级大于v
        //则合并后u必须为根节点，满足大根堆性质，于是v与其右子树合并
		u->r=merge(u->r,v),update(u);return u;
	}
	else{//反之也类似
		v->l=merge(u,v->l),update(v);return v;
	}
}
```



